{
	"TrieNode": {
		"prefix": "TrieNode",
		"body": [
			"class TrieNode:",
			"    \"\"\"TrieNode class can quickly process string prefixes, a common feature used in applications like autocomplete and spell checking.\"\"\"",
			"    _sid_cnt = 0  # sid counter, representing string index starting from 0",
			"",
			"    def __init__(self):",
			"        \"\"\"Initialize children dictionary and cost. The trie tree is a 26-ary tree.\"\"\"",
			"        self._children_ = {}",
			"        self._cost = INF",
			"        self._is_end_of_word = False  # Flag to indicate end of word",
			"        self._sid = -1  # Unique ID for the node, -1 if not assigned",
			"",
			"    def add(self, word: str, cost: int) -> int:",
			"        \"\"\"Add a word to the trie with the associated cost and return a unique ID.\"\"\"",
			"        node = self",
			"        for c in word:",
			"            if c not in node._children_:",
			"                node._children_[c] = Std.TrieNode()",
			"            node = node._children_[c]",
			"        node._cost = Math.min(node._cost, cost)",
			"        node._is_end_of_word = True  # Mark the end of the word",
			"        if node._sid < 0:",
			"            node._sid = self._sid_cnt",
			"            self._sid_cnt += 1",
			"        return node._sid",
			"",
			"    def search(self, word: str) -> List[List]:",
			"        \"\"\"Search for prefixes of 'word' in the trie and return their lengths, costs, and sids.",
			"",
			"        Collects ALL prefix lengths and their associated costs and sids!! ",
			"        Valid matches are those where node.cost != INF and node.sid != -1.",
			"        \"\"\"",
			"        node = self",
			"        ans = []",
			"        for i, c in enumerate(word):",
			"            if c not in node._children_:",
			"                break",
			"            node = node._children_[c]",
			"            ans.append([i + 1, node._cost, node._sid])  # i + 1 to denote length from start",
			"        return ans",
			"",
			"    def search_exact(self, word: str) -> int:",
			"        \"\"\"Search for the exact word in the trie and return its cost or unique ID.\"\"\"",
			"        node = self",
			"        for c in word:",
			"            if c not in node._children_:",
			"                return INF",
			"            node = node._children_[c]",
			"        return node._cost if node._is_end_of_word else INF"
		],
		"description": "TrieNode"
	},
	"TrieNodeGraph": {
		"prefix": "TrieNodeGraph",
		"body": [
			"class TrieNodeGraph:",
			"    \"\"\"TrieNode class can convert each string into an integer identifier, useful in graph theory.\"\"\"",
			"    _sid_cnt = 0  # sid counter, representing string index starting from 0",
			"    _sid_to_word_ = {}  # Dictionary mapping sid to the original string",
			"",
			"    def __init__(self):",
			"        \"\"\"Initialize children dictionary and cost. The trie tree is a 26-ary tree.\"\"\"",
			"        self._children_ = {}",
			"        self._is_end_of_word = False  # Flag to indicate end of word",
			"        self._sid = -1  # Unique ID for the node, -1 if not assigned",
			"",
			"    def add(self, word: str) -> int:",
			"        \"\"\"Add a word to the trie and return a unique ID.\"\"\"",
			"        node = self",
			"        for c in word:",
			"            if c not in node._children_:",
			"                node._children_[c] = Std.TrieNodeGraph()",
			"            node = node._children_[c]",
			"        node._is_end_of_word = True  # Mark the end of the word",
			"        if node._sid < 0:",
			"            node._sid = self._sid_cnt",
			"            self._sid_cnt += 1",
			"        self._sid_to_word_[node._sid] = word",
			"        return node._sid",
			"",
			"    def _search(self, word: str) -> int:",
			"        \"\"\"Search for the exact word in the trie and return its unique ID, else -1.\"\"\"",
			"        node = self",
			"        for c in word:",
			"            if c not in node._children_:",
			"                return -1",
			"            node = node._children_[c]",
			"        return node._sid if node._is_end_of_word else -1",
			"",
			"    def get_id(self, word: str) -> int:",
			"        \"\"\"Retrieve the unique ID for a given word.\"\"\"",
			"        return self._search(word)",
			"",
			"    def get_str(self, sid: int) -> str:",
			"        \"\"\"Retrieve the original string associated with a given unique ID.\"\"\"",
			"        return word if (word := self._sid_to_word_.get(sid)) else \"-1\""
		],
		"description": "TrieNodeGraph"
	},
	"TrieNode01": {
		"prefix": "TrieNode01",
		"body": [
			"class TrieNode01:",
			"    \"\"\"",
			"    TrieNode01 class is a binary trie optimized for operations on binary strings.",
			"    Useful for problems like finding maximum XOR of two numbers in an array.",
			"    \"\"\"",
			"",
			"    def __init__(self):",
			"        \"\"\"Initialize TrieNode01 with two children and a value.\"\"\"",
			"        self._children_: List = [None, None]  # Only two children: 0 and 1",
			"        self._value: Optional[int] = None  # Store the actual value if this is an end node",
			"        self._count = 0  # Number of numbers passing through this node",
			"",
			"    def insert(self, num: int):",
			"        \"\"\"Insert a number into the binary trie.\"\"\"",
			"        node = self",
			"        for i in range(31, -1, -1):  # Assuming 32-bit integers",
			"            bit = (num >> i) & 1",
			"            if not node._children_[bit]:",
			"                node._children_[bit] = Std.TrieNode01()",
			"            node = node._children_[bit]",
			"            node.count += 1",
			"        node._value = num  # Store the number at the leaf node",
			"",
			"    def find_max_xor(self, num: int) -> int:",
			"        \"\"\"Find the maximum XOR of 'num' with any number in the trie.\"\"\"",
			"        node = self",
			"        max_xor = 0",
			"        for i in range(31, -1, -1):  # Assuming 32-bit integers",
			"            bit = (num >> i) & 1",
			"            toggled_bit = 1 - bit",
			"            if node._children_[toggled_bit]:  # Prefer the toggled bit if it exists",
			"                max_xor = (max_xor << 1) | 1  # Current bit is 1 (since XOR with toggled bit)",
			"                node = node._children_[toggled_bit]",
			"            else:",
			"                max_xor = (max_xor << 1)  # Current bit is 0 (since XOR with the same bit)",
			"                node = node._children_[bit]",
			"        return max_xor",
			"",
			"    def count_equal(self, num: int) -> int:",
			"        \"\"\"Count the number of values in the Trie equal to the given num.\"\"\"",
			"        node = self",
			"        for i in range(31, -1, -1):",
			"            bit = (num >> i) & 1",
			"            if bit in node._children_:",
			"                node = node._children_[bit]",
			"            else:",
			"                return 0  # If the bit path does not exist, return 0",
			"        return node._count  # Return the count of values equal to the given num"
		],
		"description": "TrieNode01"
	},
	"SparseTable": {
		"prefix": "SparseTable",
		"body": [
			"class SparseTable:",
			"    def __init__(self, data: List, func=lambda x, y: x | y):",
			"        \"\"\"Initialize the Sparse Table with the given data and function.\"\"\"",
			"        self._func = func",
			"        self._st_ = [list(data)]",
			"        i, n = 1, len(self._st_[0])",
			"        while 2 * i <= n:",
			"            pre_ = self._st_[-1]",
			"            self._st_.append([func(pre_[j], pre_[j + i]) for j in range(n - 2 * i + 1)])",
			"            i <<= 1",
			"",
			"    def query(self, begin: int, end: int) -> int:",
			"        \"\"\"Query the combined result over the interval [begin, end] using O(1).\"\"\"",
			"        lg = (end - begin + 1).bit_length() - 1",
			"        return self._func(self._st_[lg][begin], self._st_[lg][end - (1 << lg) + 1])"
		],
		"description": "SparseTable"
	},
	"StringHash": {
		"prefix": "StringHash",
		"body": [
			"class StringHash:",
			"    \"\"\"A class for efficiently computing hash values of substrings within a string.\"\"\"",
			"",
			"    def __init__(self, s: str, mod: int = 1_070_777_777):",
			"        \"\"\"Initialize the StringHash object with the string, base, and mod.\"\"\"",
			"        self._mod = mod",
			"        self._base = random.randint(8 * 10 ** 8, 9 * 10 ** 8)",
			"        self._s = s",
			"        self._n = len(s)",
			"        self._pow_base_ = [1] + Arr.array(0, self._n)  # pow_base[i] = BASE ^ i",
			"        self._pre_hash_ = Arr.array(0, self._n + 1)  # pre_hash[i] = hash(s[:i])",
			"        self._compute_hash()",
			"",
			"    def _compute_hash(self):",
			"        \"\"\"Compute the prefix hash values and power of base values for the string.\"\"\"",
			"        for i, b in enumerate(self._s):",
			"            self._pow_base_[i + 1] = self._pow_base_[i] * self._base % self._mod",
			"            self._pre_hash_[i + 1] = (self._pre_hash_[i] * self._base + ord(b)) % self._mod",
			"",
			"    def get_hash(self, l: int, r: int) -> int:",
			"        \"\"\"Get the hash value of the substring s[l:r] \"\"\"",
			"        return (self._pre_hash_[r + 1] - self._pre_hash_[l] * self._pow_base_[r - l + 1] % self._mod + self._mod) % self._mod",
			"",
			"    def compute_hash(self, word: str) -> int:",
			"        \"\"\"Compute the hash value of a given word using the object's base and mod.\"\"\"",
			"        h = 0",
			"        for b in word:",
			"            h = (h * self._base + ord(b)) % self._mod",
			"        return h"
		],
		"description": "StringHash"
	},
	"PrefixSum": {
		"prefix": "PrefixSum",
		"body": [
			"class PrefixSum:",
			"    def __init__(self, nums: List[int]):",
			"        \"\"\"Initializes the PrefixSum object with the given list of numbers.",
			"",
			"        Args:",
			"            nums (List[int]): The input array of integers (0-based index).",
			"        \"\"\"",
			"        self._n = len(nums)",
			"        self._prefix_sum_ = Arr.array(0, self._n + 1)  # 1-based index",
			"",
			"        # Compute the prefix sum with adjusted indexing",
			"        for i in range(1, self._n + 1):",
			"            # Adjust nums index by subtracting 1 to map 1-based prefix_sum to 0-based nums",
			"            self._prefix_sum_[i] = self._prefix_sum_[i - 1] + nums[i - 1]",
			"",
			"    def query(self, left: int, right: int) -> int:",
			"        \"\"\"Returns the sum of elements in the range [left, right]. The input coordinates is 0-based indexing.\"\"\"",
			"        # Convert the 0-based indices to 1-based by adding 1",
			"        return self._prefix_sum_[right + 1] - self._prefix_sum_[left]"
		],
		"description": "PrefixSum"
	},
	"PrefixSumTwoDim": {
		"prefix": "PrefixSumTwoDim",
		"body": [
			"class PrefixSumTwoDim:",
			"    def __init__(self, matrix: List[List[int]]):",
			"        \"\"\"Initializes the PrefixSumTwoDim object with the given matrix.",
			"",
			"        Args:",
			"            matrix (List[List[int]]): The input 2D array of integers (0-based index).",
			"        \"\"\"",
			"        self._rows = len(matrix)",
			"        self._cols = len(matrix[0])",
			"        self._prefix_sum_ = Arr.array2d(0, self._cols + 1, self._rows + 1)  # 1-based index",
			"",
			"        # Compute the prefix sum with adjusted indexing",
			"        for i in range(1, self._rows + 1):",
			"            for j in range(1, self._cols + 1):",
			"                # Adjust matrix indices by subtracting 1 to map 1-based prefix_sum to 0-based matrix",
			"                self._prefix_sum_[i][j] = matrix[i - 1][j - 1] + self._prefix_sum_[i - 1][j] + self._prefix_sum_[i][j - 1] - self._prefix_sum_[i - 1][j - 1]",
			"",
			"    def query(self, x1: int, y1: int, x2: int, y2: int) -> int:",
			"        \"\"\"Returns the sum of the submatrix from (x1, y1) to (x2, y2). The input coordinates is 0-based indexing.\"\"\"",
			"        # Convert the 0-based indices to 1-based by adding 1",
			"        return self._prefix_sum_[x2 + 1][y2 + 1] - self._prefix_sum_[x1][y2 + 1] - self._prefix_sum_[x2 + 1][y1] + self._prefix_sum_[x1][y1]"
		],
		"description": "PrefixSumTwoDim"
	},
	"Bisect": {
		"prefix": "Bisect",
		"body": [
			"class Bisect:",
			"    @staticmethod",
			"    def bisect_left(a, x, key=lambda y: y, lo=0, hi=None) -> int:",
			"        \"\"\"The insertion point is the first position where the element is not less than x.\"\"\"",
			"        if hi is None:",
			"            hi = len(a)",
			"        left, right = lo, hi",
			"        while left < right:",
			"            mid = (left + right) >> 1",
			"            if key(a[mid]) < x:",
			"                left = mid + 1",
			"            else:",
			"                right = mid",
			"        return left  # If not found, returns hi (insertion point)",
			"",
			"    @staticmethod",
			"    def bisect_right(a, x, key=lambda y: y, lo=0, hi=None) -> int:",
			"        \"\"\"The insertion point is the first position where the element is greater than x.\"\"\"",
			"        if hi is None:",
			"            hi = len(a)",
			"        left, right = lo, hi",
			"        while left < right:",
			"            mid = (left + right) >> 1",
			"            if key(a[mid]) <= x:",
			"                left = mid + 1",
			"            else:",
			"                right = mid",
			"        return left  # If not found, returns hi (insertion point)"
		],
		"description": "Bisect"
	},
	"Func (3.8.19)": {
		"prefix": "Func",
		"body": [
			"class Func:",
			"    @staticmethod",
			"    def find(container, value) -> int:",
			"        \"\"\"Returns the index of value in container or -1 if value is not found.\"\"\"",
			"        if isinstance(container, list):",
			"            try:",
			"                return container.index(value)",
			"            except ValueError:",
			"                return -1",
			"        elif isinstance(container, str):",
			"            return container.find(value) # type: ignore",
			"        ",
			"    @staticmethod",
			"    def pairwise(iterable):",
			"        \"\"\"Return successive overlapping pairs taken from the input iterable.\"\"\"",
			"        a, b = tee(iterable)",
			"        next(b, None)",
			"        return zip(a, b)"
		],
		"description": "Func (3.8.19) Supplement"
	},
	"TreeAncestor": {
		"prefix": "TreeAncestor",
		"body": [
			"class TreeAncestor:",
			"    \"\"\"",
			"    Binary Lifting for Tree Ancestor Queries, allows us to find the 2^i-th ancestor of any node.",
			"    Ensure that each node has only one edge pointing to another node to apply binary lifting.",
			"    \"\"\"",
			"",
			"    def __init__(self, n: int, m: int, parent: List[int]):",
			"        \"\"\"",
			"        Initializes the TreeAncestor with the given number of nodes and parent list.",
			"",
			"        Args:",
			"            n (int): Number of nodes.",
			"            m (int): Maximum power of 2 to consider.",
			"            parent (List[int]): List where parent[i] is the parent of node i.",
			"        \"\"\"",
			"        # Default: m = n.bit_length(). This is because, at most, a node could have up to 2^m ancestors. However, the appearance of CYCLE may lead to m being more than n.bit_length().",
			"        self._n = n",
			"        self._m = m",
			"        pa_ = [[p] + Arr.array(-1, m - 1) for p in parent]  # pa[i][0] = p",
			"        for i in range(m - 1):  # handle parent nodes exclude itself.",
			"            for x in range(n):",
			"                p = pa_[x][i]  # Get the 2^i-th ancestor of node x",
			"                if p != -1:",
			"                    pp = pa_[p][i]  # Get the 2^i-th ancestor of p, which will be the 2^(i+1)-th ancestor of x",
			"                    pa_[x][i + 1] = pp  # Set the 2^(i+1)-th ancestor of x",
			"        self._pa_ = pa_",
			"",
			"    def get_kth_ancestor(self, node: int, k: int) -> int:",
			"        \"\"\"Returns the k-th ancestor of the given node (The starting node). If not exists, return -1\"\"\"",
			"        for j in range(k.bit_length()):",
			"            if (k >> j) & 1:",
			"                node = self._pa_[node][j]",
			"                if node < 0:",
			"                    break",
			"        return node"
		],
		"description": "TreeAncestor"
	},
	"LCA": {
		"prefix": "LCA",
		"body": [
			"class LCA:",
			"    \"\"\"Useing TreeAncestor calculate LCA\"\"\"",
			"",
			"    def __init__(self, edges: List[List[int]]):",
			"        n = len(edges) + 1",
			"        m = n.bit_length()",
			"        g = Arr.graph(n)",
			"        for x, y in edges:  # Node indices start from 0",
			"            g[x].append(y)",
			"            g[y].append(x)",
			"",
			"        depth_ = Arr.array(0, n)",
			"        pa_ = Arr.array2d(-1, n, m)",
			"",
			"        def _dfs(x: int, fa: int) -> None:",
			"            \"\"\"Depth-first search to initialize the ancestor table and depth array.\"\"\"",
			"            pa_[x][0] = fa  # init itself",
			"            for y in g[x]:",
			"                if y != fa:",
			"                    depth_[y] = depth_[x] + 1",
			"                    _dfs(y, x)",
			"        _dfs(0, -1)",
			"",
			"        for i in range(m - 1):",
			"            for x in range(n):",
			"                p = pa_[x][i]  # Get the 2^i-th ancestor of node x",
			"                if p != -1:",
			"                    pp = pa_[p][i]  # Get the 2^i-th ancestor of p, which will be the 2^(i+1)-th ancestor of x",
			"                    pa_[x][i + 1] = pp  # Set the 2^(i+1)-th ancestor of x",
			"        self._depth_ = depth_",
			"        self._pa_ = pa_",
			"",
			"    def get_kth_ancestor(self, node: int, k: int) -> int:",
			"        \"\"\"Returns the k-th ancestor of the given node (The starting node). That is, jump up k steps\"\"\"",
			"        for i in range(k.bit_length()):",
			"            if (k >> i) & 1:",
			"                node = self._pa_[node][i]",
			"                if node < 0:",
			"                    break",
			"        return node",
			"",
			"    def get_lca(self, x: int, y: int) -> int:",
			"        \"\"\"Returns the Lowest Common Ancestor (LCA) of nodes x and y.\"\"\"",
			"        if self._depth_[x] > self._depth_[y]:",
			"            x, y = y, x",
			"        # Bring y and x to the same depth",
			"        y = self.get_kth_ancestor(y, self._depth_[y] - self._depth_[x])",
			"        if y == x:",
			"            return x",
			"        for i in range(len(self._pa_[x]) - 1, -1, -1):",
			"            px, py = self._pa_[x][i], self._pa_[y][i]",
			"            if px != py:",
			"                x, y = px, py  # Move both nodes up by 2^i steps",
			"        return self._pa_[x][0]  # Return the parent of x (or y) as LCA"
		],
		"description": "LCA"
	},
	"Floyd": {
		"prefix": "Floyd",
		"body": [
			"class Floyd:",
			"    \"\"\"Floyd-Warshall algorithm\"\"\"",
			"",
			"    def __init__(self, n: int):",
			"        self._n = n",
			"        self._g_ = Arr.graph(n)",
			"        self.dist_ = Arr.array2d(INF, self._n, self._n)",
			"        self.dp_ = Arr.array(0, n)",
			"",
			"    def add_edge(self, u: int, v: int, w: int):",
			"        \"\"\"Add an edge to the graph.\"\"\"",
			"        self._g_[u].append((v, w))",
			"",
			"    def floyd(self):",
			"        \"\"\"Floyd's algorithm for finding the shortest paths between all pairs of nodes.\"\"\"",
			"        # Initialize distances with the given edges",
			"        for u in range(self._n):",
			"            for v, w in self._g_[u]:",
			"                self.dist_[u][v] = Math.min(self.dist_[u][v], w)",
			"",
			"        # Set the diagonal to zero",
			"        for i in range(self._n):",
			"            self.dist_[i][i] = 0",
			"",
			"        for k in range(self._n):",
			"            for i in range(self._n):",
			"                if self.dist_[i][k] > INF // 2:  # If there is no path from i to k, skip",
			"                    continue",
			"                for j in range(self._n):",
			"                    if self.dist_[i][j] > self.dist_[i][k] + self.dist_[k][j]:",
			"                        self.dist_[i][j] = self.dist_[i][k] + self.dist_[k][j]",
			"",
			"    def floyd_01(self):",
			"        \"\"\"Floyd's algorithm for finding reachability between all pairs of nodes using bitwise operations.\"\"\"",
			"        n = self._n",
			"        for u in range(n):",
			"            self.dp_[u] |= 1 << u  # Each node can reach itself",
			"            for v, _ in self._g_[u]:",
			"                self.dp_[u] |= 1 << v  # Add reachable nodes based on edges",
			"",
			"        for k in range(n):",
			"            for i in range(n):",
			"                if self.dp_[i] >> k & 1:  # If i can reach k",
			"                    self.dp_[i] |= self.dp_[k]  # Then i can also reach all nodes k can reach",
			"",
			"    def get_dist(self, x: int, y: int) -> int:",
			"        \"\"\"Get distance between x and y.\"\"\"",
			"        return self.dist_[x][y] if self.dist_[x][y] < INF // 2 else INF",
			"",
			"    def get_dist_01(self, x: int, y: int) -> bool:",
			"        \"\"\"Get whether exists path between x and y.\"\"\"",
			"        return self.dp_[x] >> y & 1"
		],
		"description": "Floyd"
	},
	"Spfa": {
		"prefix": "Spfa",
		"body": [
			"class Spfa:",
			"    def __init__(self, n: int):",
			"        self._n = n",
			"        self._g_ = Arr.graph(n)",
			"",
			"    def add_edge(self, u: int, v: int, w: int):",
			"        \"\"\"Add an edge to the graph.\"\"\"",
			"        self._g_[u].append((v, w))",
			"",
			"    def spfa(self, s: int) -> List[int]:",
			"        \"\"\"SPFA (Shortest Path Faster Algorithm) for finding the shortest path in a graph.\"\"\"",
			"        dist = Arr.array(INF, self._n)",
			"        st = Arr.array(0, self._n)",
			"        q = deque()",
			"",
			"        dist[s] = 0",
			"        q.appendleft(s)",
			"        st[s] = 1",
			"",
			"        while q:",
			"            u = q.pop()",
			"            st[u] = 0",
			"            for v, w in self._g_[u]:",
			"                if dist[v] > dist[u] + w:",
			"                    dist[v] = dist[u] + w",
			"                    if st[v] == 0:",
			"                        q.appendleft(v)",
			"                        st[v] = 1",
			"",
			"        return dist"
		],
		"description": "Spfa"
	},
	"Dijkstra": {
		"prefix": "Dijkstra",
		"body": [
			"class Dijkstra:",
			"    \"\"\"Dijkstra's algorithm for finding the shortest path in a weighted graph, designed to compute various properties related to the shortest paths from a source node.\"\"\"",
			"",
			"    def __init__(self, n: int, val_: List):",
			"        self.n = n  # Number of nodes in the graph",
			"        self.val_ = val_  # Node values (weights associated with each node)",
			"        self.g_ = Arr.graph(n)  # Adjacency list to store the graph",
			"        self.dist_ = Arr.array(INF, n)  # Shortest distance from the source to each node",
			"        self.sum_ = Arr.array(0, n)  # Sum of node values along the shortest path",
			"        self.cnt_ = Arr.array(0, n)  # Count of shortest paths",
			"        self.pre_ = Arr.array(0, n)  # Predecessor node in the shortest path",
			"        self.num_ = Arr.array(0, n)  # Number of nodes in the shortest path",
			"",
			"    def add_edge(self, u: int, v: int, w: int):",
			"        \"\"\"Add an edge to the graph.\"\"\"",
			"        self.g_[u].append((v, w))",
			"",
			"    def dijkstra(self, s: int):",
			"        \"\"\"Dijkstra's algorithm for finding the shortest path in a graph.",
			"        This method calculates the shortest distances, maximizes the sum of node values (`val_`) along the paths, and minimizes the number of edges (`num_`) used in the paths. Additionally, it counts the number of distinct shortest paths to each node.\"\"\"",
			"        st_ = Arr.array(0, self.n)",
			"        q = []",
			"",
			"        self.dist_[s] = 0",
			"        self.sum_[s] = self.val_[s]",
			"        self.cnt_[s] = self.num_[s] = 1",
			"        heappush(q, (0, s))",
			"",
			"        while q:",
			"            _, u = heappop(q)",
			"            if st_[u]:",
			"                continue",
			"            st_[u] = 1",
			"            for v, w in self.g_[u]:",
			"                if self.dist_[v] > self.dist_[u] + w:",
			"                    self.dist_[v] = self.dist_[u] + w",
			"                    self.pre_[v] = u",
			"                    self.sum_[v] = self.sum_[u] + self.val_[v]",
			"                    self.num_[v] = self.num_[u] + 1",
			"                    self.cnt_[v] = self.cnt_[u]",
			"                    heappush(q, (self.dist_[v], v))",
			"                elif self.dist_[v] == self.dist_[u] + w:",
			"                    self.cnt_[v] += self.cnt_[u]",
			"                    if self.sum_[u] > self.sum_[self.pre_[v]]:",
			"                        self.pre_[v] = u",
			"                        self.sum_[v] = self.sum_[u] + self.val_[v]",
			"                        self.num_[v] = self.num_[u] + 1",
			"                        heappush(q, (self.dist_[v], v))",
			"                    elif self.sum_[u] == self.sum_[self.pre_[v]] and self.num_[v] > self.num_[u] + 1:",
			"                        self.pre_[v] = u",
			"                        self.num_[v] = self.num_[u] + 1",
			"                        heappush(q, (self.dist_[v], v))"
		],
		"description": "Dijkstra"
	},
	"Dijkstra(simple)": {
		"prefix": "Dijkstra(simple)",
		"body": [
			"class Dijkstra:",
			"    \"\"\"Dijkstra's algorithm for finding the shortest path in a weighted graph, designed to compute various properties related to the shortest paths from a source node.\"\"\"",
			"",
			"    def __init__(self):",
			"        self.g_ = defaultdict(list)  # Adjacency list to store the graph",
			"        self.dist_ = defaultdict(lambda: INF)",
			"",
			"    def add_edge(self, u: int, v: int, w: int):",
			"        \"\"\"Add an edge to the graph.\"\"\"",
			"        self.g_[u].append((v, w))",
			"",
			"    def dijkstra(self, s: int):",
			"        \"\"\"Dijkstra's algorithm for finding the shortest path in a graph.\"\"\"",
			"        st_ = defaultdict(lambda: False)",
			"        q = []",
			"        self.dist_[s] = 0",
			"        heappush(q, (0, s))",
			"",
			"        while q:",
			"            _, u = heappop(q)",
			"            if st_[u]:",
			"                continue",
			"            st_[u] = True",
			"            for v, w in self.g_[u]:",
			"                if self.dist_[v] > self.dist_[u] + w:",
			"                    self.dist_[v] = self.dist_[u] + w",
			"                    heappush(q, (self.dist_[v], v))"
		],
		"description": "Dijkstra(simple)"
	},
	"Str": {
		"prefix": "Str",
		"body": [
			"class Str:",
			"    atoi = staticmethod(lambda x: ord(x.upper()) - 65)  # A -> 0",
			"    itoa = staticmethod(lambda x: ascii_uppercase[x])   # 0 -> A",
			"    removeprefix = staticmethod(lambda s, prefix: s[len(prefix):] if s.startswith(prefix) else s)",
			"    removesuffix = staticmethod(lambda s, suffix: s[:-len(suffix)] if s.endswith(suffix) else s)"
		],
		"description": "Str"
	},
	"IO": {
		"prefix": "IO",
		"body": [
			"class IO:",
			"    input = staticmethod(lambda: stdin.readline().strip())",
			"    read = staticmethod(lambda: map(int, IO.input().split()))",
			"    read_list = staticmethod(lambda: list(IO.read()))",
			"    read_mixed = staticmethod(lambda *types: [t(v) for t, v in zip(types, IO.input().split())])"
		],
		"description": "IO"
	},
	"Mod": {
		"prefix": "Mod",
		"body": [
			"class Mod:",
			"    add = staticmethod(lambda *args: (lambda result=0: [(result := (result + num) % MOD) for num in args] and result)())",
			"    sub = staticmethod(lambda a, b: (a - b + MOD) % MOD)",
			"    mul = staticmethod(lambda *args: (lambda result=1: [(result := (result * num) % MOD) for num in args] and result)())",
			"    div = staticmethod(lambda a, b: (a * pow(b, MOD - 2, MOD)) % MOD)",
			"    mod = staticmethod(lambda a: (a % MOD + MOD) % MOD)"
		],
		"description": "Mod"
	},
	"BipartiteMatcher": {
		"prefix": "BipartiteMatcher",
		"body": [
			"class BipartiteMatcher:",
			"    def __init__(self, n: int):",
			"        \"\"\"Initialize the BipartiteMatcher with n nodes.\"\"\"",
			"        self._n = n",
			"        self._match_ = Arr.array(0, self._n)",
			"        self._st_ = Arr.array(0, self._n)",
			"        self._g_ = Arr.graph(self._n)",
			"",
			"    def add_edge(self, u: int, v: int):",
			"        \"\"\"Add an edge between node u and node v.\"\"\"",
			"        self._g_[u].append(v)",
			"",
			"    def find(self, u: int) -> bool:",
			"        \"\"\"Find an augmenting path starting from node u.\"\"\"",
			"        for v in self._g_[u]:",
			"            if self._st_[v] == 0:",
			"                self._st_[v] = 1",
			"                if self._match_[v] == 0 or self.find(self._match_[v]):",
			"                    self._match_[v] = u",
			"                    return True",
			"        return False",
			"",
			"    def max_matching(self) -> int:",
			"        \"\"\"Compute the maximum matching in the bipartite graph.\"\"\"",
			"        res = 0",
			"        for i in range(self._n):",
			"            self._st_ = Arr.array(0, self._n)",
			"            if self.find(i):",
			"                res += 1",
			"        return res"
		],
		"description": "BipartiteMatcher"
	},
	"SegTree": {
		"prefix": "SegTree",
		"body": [
			"class SegTree:",
			"    \"\"\"",
			"    A segment tree based on dynamic binary tree algorithm. ",
			"    Supports passing callback functions `f1` and `f2` to handle range queries (RMQ) such as range sum, range maximum, and range minimum.",
			"    \"\"\"",
			"",
			"    def __init__(self, f1: Callable, f2: Callable, l: int, r: int, v: int = 0):",
			"        \"\"\"",
			"        Initializes the segment tree [left, right).",
			"",
			"        Example functions:",
			"            Segment Sum:",
			"                f1 = lambda a, b: a + b",
			"                f2 = lambda a, n: a * n",
			"            Segment Maximum:",
			"                f1 = lambda a, b: Math.max(a, b)",
			"                f2 = lambda a, n: a",
			"            Segment Minimum:",
			"                f1 = lambda a, b: Math.min(a, b)",
			"                f2 = lambda a, n: a",
			"        Args:",
			"            f1: Function for combining segment values. (merge values from different intervals)",
			"            f2: Function for applying values to segments. (Spread a value to an interval)",
			"            l (int): Left boundary of the segment.",
			"            r (int): Right boundary of the segment.",
			"            v (int): Initial value for the segment.",
			"        \"\"\"",
			"        self._default = v  # Default value for the segments",
			"        self._ans = f2(v, r-l)  # Current result of the segment",
			"        self._f1 = f1",
			"        self._f2 = f2",
			"        self._l = l  # left",
			"        self._r = r  # right",
			"        self._v = v  # init value",
			"        self._lazy_tag = 0  # Lazy tag",
			"        self._left = None  # SubTree(left, bottom)",
			"        self._right = None  # SubTree(right, bottom)",
			"",
			"    def __repr__(self) -> str:",
			"        \"\"\"Returns values of the segment.\"\"\"",
			"        anss = []",
			"        for i in range(self._l, self._r):",
			"            anss.append(str(self.query(i, i + 1)))",
			"        return \"seg: \" + \" \".join(anss)",
			"",
			"    @property",
			"    def _mid_h(self) -> int:",
			"        \"\"\"Returns the midpoint of the segment.\"\"\"",
			"        return self._l + self._r >> 1",
			"",
			"    def _create_subtrees(self):",
			"        \"\"\"Creates left and right subtrees if they do not exist.\"\"\"",
			"        midh = self._mid_h",
			"        if not self._left and midh > self._l:",
			"            self._left = Std.SegTree(self._f1, self._f2, self._l, midh, self._default)",
			"        if not self._right:",
			"            self._right = Std.SegTree(self._f1, self._f2, midh, self._r, self._default)",
			"",
			"    def build(self, arr: List[int]) -> int:",
			"        \"\"\"",
			"        Initializes the segment tree with values from arr.",
			"",
			"        Args:",
			"            arr: List of values to initialize the segment tree.",
			"",
			"        Returns:",
			"            The combined value of the segment tree.",
			"        \"\"\"",
			"        m0 = arr[0]",
			"        self._lazy_tag = 0",
			"        if self._r == self._l + 1:",
			"            self._v = m0",
			"            self._ans = self._f2(m0, len(arr))",
			"            return self._ans",
			"        self._v = '#'",
			"        midh = self._mid_h",
			"        self._create_subtrees()",
			"        self._ans = self._f1(self._left.build(arr[:midh - self._l]), self._right.build(arr[midh - self._l:]))",
			"        return self._ans",
			"",
			"    def cover_seg(self, l: int, r: int, v: int) -> int:",
			"        \"\"\"",
			"        Covers the segment [left, right) with value v.",
			"",
			"        Args:",
			"            l (int): Left boundary of the cover range.",
			"            r (int): Right boundary of the cover range.",
			"            v: Value to cover the segment with.",
			"",
			"        Returns:",
			"            The combined value of the segment tree.",
			"        \"\"\"",
			"        if self._v == v or l >= self._r or r <= self._l:",
			"            return self._ans",
			"        if l <= self._l and r >= self._r:",
			"            self._v = v",
			"            self._lazy_tag = 0",
			"            self._ans = self._f2(v, self._r - self._l)",
			"            return self._ans",
			"        self._create_subtrees()",
			"        if self._v != '#':",
			"            self._left._v = self._v",
			"            self._left._ans = self._f2(self._v, self._left._r - self._left._l)",
			"            self._right._v = self._v",
			"            self._right._ans = self._f2(self._v, self._right._r - self._right._l)",
			"            self._v = '#'",
			"        # push up",
			"        self._ans = self._f1(self._left.cover_seg(l, r, v), self._right.cover_seg(l, r, v))",
			"        return self._ans",
			"",
			"    def inc_seg(self, l: int, r: int, v: int) -> int:",
			"        \"\"\"",
			"        Increases the segment [left, right) by value v.",
			"",
			"        Args:",
			"            l (int): Left boundary of the increase range.",
			"            r (int): Right boundary of the increase range.",
			"            v: Value to increase the segment by.",
			"",
			"        Returns:",
			"            The combined value of the segment tree.",
			"        \"\"\"",
			"        if v == 0 or l >= self._r or r <= self._l:",
			"            return self._ans",
			"        if l <= self._l and r >= self._r:",
			"            if self._v == '#':",
			"                self._lazy_tag += v",
			"            else:",
			"                self._v += v",
			"            self._ans += self._f2(v, self._r - self._l)",
			"            return self._ans",
			"        self._create_subtrees()",
			"        if self._v != '#':",
			"            self._left._v = self._v",
			"            self._left._ans = self._f2(self._v, self._left._r - self._left._l)",
			"            self._right._v = self._v",
			"            self._right._ans = self._f2(self._v, self._right._r - self._right._l)",
			"            self._v = '#'",
			"        self._pushdown()",
			"        # push up",
			"        self._ans = self._f1(self._left.inc_seg(l, r, v), self._right.inc_seg(l, r, v))",
			"        return self._ans",
			"",
			"    def inc_idx(self, idx: int, v: int) -> int:",
			"        \"\"\"",
			"        Increases the value at index idx by value v.",
			"",
			"        Args:",
			"            idx (int): Index to increase.",
			"            v: Value to increase by.",
			"",
			"        Returns:",
			"            The combined value of the segment tree.",
			"        \"\"\"",
			"        if v == 0 or idx >= self._r or idx < self._l:",
			"            return self._ans",
			"        if idx == self._l == self._r - 1:",
			"            self._v += v",
			"            self._ans += self._f2(v, 1)",
			"            return self._ans",
			"        self._create_subtrees()",
			"        if self._v != '#':",
			"            self._left._v = self._v",
			"            self._left._ans = self._f2(self._v, self._left._r - self._left._l)",
			"            self._right._v = self._v",
			"            self._right._ans = self._f2(self._v, self._right._r - self._right._l)",
			"            self._v = '#'",
			"        self._pushdown()",
			"        # push up",
			"        self._ans = self._f1(self._left.inc_idx(idx, v), self._right.inc_idx(idx, v))",
			"        return self._ans",
			"",
			"    def _pushdown(self):",
			"        \"\"\"Propagates the lazy tag to the child nodes.\"\"\"",
			"        if self._lazy_tag != 0:",
			"            if self._left._v != '#':",
			"                self._left._v += self._lazy_tag",
			"            else:",
			"                self._left._lazy_tag += self._lazy_tag",
			"            self._left._ans += self._f2(self._lazy_tag, self._left._r - self._left._l)",
			"            if self._right._v != '#':",
			"                self._right._v += self._lazy_tag",
			"            else:",
			"                self._right._lazy_tag += self._lazy_tag",
			"            self._right._ans += self._f2(self._lazy_tag, self._right._r - self._right._l)",
			"            self._lazy_tag = 0",
			"",
			"    def query(self, l: int, r: int) -> int:",
			"        \"\"\"",
			"        Queries the range [left, right) for the combined value.",
			"",
			"        Args:",
			"            l (int): Left boundary of the query range.",
			"            r (int): Right boundary of the query range.",
			"",
			"        Returns:",
			"            The combined value of the range.",
			"        \"\"\"",
			"        if l >= r:",
			"            return 0",
			"        if l <= self._l and r >= self._r:",
			"            return self._ans",
			"        if self._v != '#':",
			"            return self._f2(self._v, Math.min(self._r, r) - Math.max(self._l, l))  # the overlapping length",
			"        self._create_subtrees()",
			"        midh = self._mid_h",
			"        self._pushdown()",
			"        ans_ = []",
			"        if l < midh:",
			"            ans_.append(self._left.query(l, r))",
			"        if r > midh:",
			"            ans_.append(self._right.query(l, r))",
			"        return reduce(self._f1, ans_)",
			"",
			"    @staticmethod",
			"    def discretize(array):",
			"        \"\"\"Discretize the array and return the mapping dictionary. Index starts from 1\"\"\"",
			"        sorted_unique = sorted(set(array))",
			"        mapping = {val: idx + 1 for idx, val in enumerate(sorted_unique)}",
			"        return [mapping[val] for val in array], mapping"
		],
		"description": "SegTree"
	},
	"KMP": {
		"prefix": "KMP",
		"body": [
			"class KMP:",
			"    def __init__(self, t: str):",
			"        \"\"\"Initializes the KMP object with a text string.\"\"\"",
			"        self.t = t",
			"",
			"    def _calc_mml(self, p: str) -> List[int]:",
			"        \"\"\"Constructs the maximum match lengths table for the pattern.",
			"",
			"        Args:",
			"            p (str): The pattern string for which the table is constructed.",
			"",
			"        Returns:",
			"            List[int]: The list of maximum match lengths for the pattern string.",
			"        \"\"\"",
			"        mml_, j = Arr.array(0, len(p)), 0  # Initialize max match lengths array and max length",
			"        for i in range(1, len(p)):",
			"            while j > 0 and p[j] != p[i]:  # Backtrack to find the longest prefix which is also a suffix",
			"                j = mml_[j - 1]",
			"            if p[j] == p[i]:  # If characters match, extend the length of the prefix",
			"                j += 1",
			"            mml_[i] = j  # Store the max length at this position",
			"        return mml_",
			"",
			"    def search(self, p: str) -> List[int]:",
			"        \"\"\"Searches for all occurrences of the pattern in the text.",
			"",
			"        Args:",
			"            p (str): The pattern string to search for within the text.",
			"",
			"        Returns:",
			"            List[int]: A list of starting indices where the pattern is found in the text.",
			"        \"\"\"",
			"        mml_ = self._calc_mml(p)  # Compute max match lengths for the pattern",
			"        pos_ = []  # List to store the starting indices of matches",
			"        cnt = 0  # Number of characters currently matched",
			"        for i in range(len(self.t)):",
			"            while cnt > 0 and p[cnt] != self.t[i]:  # If there's a mismatch, backtrack using max match lengths table",
			"                cnt = mml_[cnt - 1]",
			"            if p[cnt] == self.t[i]:  # If characters match, advance the match length",
			"                cnt += 1",
			"            if cnt == len(p):  # If a full match is found, record the start position and backtrack",
			"                pos_.append(i - len(p) + 1)",
			"                cnt = mml_[cnt - 1]",
			"",
			"        return pos_"
		],
		"description": "KMP"
	},
	"Z(EXKMP)": {
		"prefix": "EXKMP",
		"body": [
			"class EXKMP:",
			"    def __init__(self, s: str):",
			"        \"\"\"Initializes the Z object with a string.\"\"\"",
			"        self.s = s",
			"",
			"    def calc_z(self) -> list[int]:",
			"        \"\"\"Constructs the Z-array for the string.",
			"",
			"        Returns:",
			"            List[int]: The Z-array representing the longest prefix matches for each index.",
			"        \"\"\"",
			"        n = len(self.s)",
			"        z = Arr.array(0, n)",
			"        box_l = box_r = 0  # Initialize the Z-box boundaries",
			"        for i in range(1, n):",
			"            if i <= box_r:",
			"                # Use previously computed Z-values to skip unnecessary comparisons",
			"                z[i] = Math.min(z[i - box_l], box_r - i + 1)",
			"            while i + z[i] < n and self.s[z[i]] == self.s[i + z[i]]:",
			"                # Expand the Z-box if characters match",
			"                z[i] += 1",
			"                box_l, box_r = i, i + z[i] - 1  # Update the Z-box boundaries",
			"        return z"
		],
		"description": "Z(EXKMP)"
	},
	"Comb": {
		"prefix": "Comb",
		"body": [
			"class Comb:",
			"    def __init__(self, max_n: int):",
			"        \"\"\"Initialize and precompute factorials and inverse factorials up to max_n.\"\"\"",
			"        self._max_n = max_n",
			"        self._fac_: List[int] = Arr.array(1, max_n + 1)",
			"        self._inv_fac_: List[int] = Arr.array(1, max_n + 1)",
			"        self._init_factorials()",
			"",
			"    def _init_factorials(self):",
			"        \"\"\"Precompute factorials and inverse factorials.\"\"\"",
			"        for i in range(2, self._max_n + 1):",
			"            self._fac_[i] = Math.Mod.mul(self._fac_[i - 1], i)",
			"        self._inv_fac_[self._max_n] = pow(self._fac_[self._max_n], MOD - 2, MOD)",
			"        for i in range(self._max_n - 1, 0, -1):",
			"            self._inv_fac_[i] = Math.Mod.mul(self._inv_fac_[i + 1], i + 1)",
			"        self._inv_fac_[0] = 1",
			"",
			"    def comb_basic(self, n: int, k: int) -> int:",
			"        \"\"\"Calculate combination C(n, k) using precomputed factorials.\"\"\"",
			"        if k > n or k < 0:",
			"            return 0",
			"        return Math.Mod.mul(self._fac_[n], Math.Mod.mul(self._inv_fac_[k], self._inv_fac_[n - k]))",
			"",
			"    def comb_lucas(self, n: int, m: int) -> int:",
			"        \"\"\"Calculate combination C(n, m) using Lucas theorem for large numbers. And max_n should be MOD, max_n is guaranteed to be a prime.\"\"\"",
			"        if m == 0:",
			"            return 1",
			"        ni = n % MOD",
			"        mi = m % MOD",
			"        return Math.Mod.mul(self.comb_basic(ni, mi), self.comb_lucas(n // MOD, m // MOD))",
			"",
			"    @staticmethod",
			"    def comb_yanghui(n: int, k: int) -> int:",
			"        \"\"\"Calculate combination C(n, k) using Pascal's triangle (Yanghui's triangle).\"\"\"",
			"        if k > n or k < 0:",
			"            return 0",
			"        c = Arr.array2d(0, n + 1, n + 1)",
			"        c[0][0] = 1",
			"        for i in range(1, n + 1):",
			"            c[i][0] = c[i][i] = 1",
			"            for j in range(1, i):",
			"                c[i][j] = Math.Mod.add(c[i - 1][j - 1], c[i - 1][j])",
			"        return c[n][k]",
			"",
			"    @staticmethod",
			"    def comb_direct(n: int, k: int) -> int:",
			"        \"\"\"Calculate combination C(n, k) using math.comb directly.\"\"\"",
			"        return comb(n, k) % MOD"
		],
		"description": "Comb"
	},
	"UnionFind": {
		"prefix": "UnionFind",
		"body": [
			"class UnionFind:",
			"    \"\"\"Union-Find data structure.\"\"\"",
			"",
			"    def __init__(self, n: int):",
			"        self.n = n",
			"        self.comp_cnt = n  # Initially, each element is its own component",
			"        self._pa_ = list(range(n))  # Parent pointers",
			"        self.size_ = Arr.array(1, n)  # Size arrays for each node",
			"",
			"    def find(self, p: int) -> int:",
			"        \"\"\"Find the root of the element p using non-recursive path compression.\"\"\"",
			"        root = p",
			"        while self._pa_[root] != root:",
			"            root = self._pa_[root]",
			"        while self._pa_[p] != root:",
			"            self._pa_[p], p = root, self._pa_[p]",
			"        return root",
			"",
			"    def union(self, p: int, q: int) -> int:",
			"        \"\"\"Merge the set containing p into the set containing q.\"\"\"",
			"        root_p = self.find(p)",
			"        root_q = self.find(q)",
			"        if root_p != root_q:",
			"            self._pa_[root_p] = root_q",
			"            self.size_[root_q] += self.size_[root_p]",
			"            self.comp_cnt -= 1  # Decrease component count as two components are merged",
			"        return root_q"
		],
		"description": "UnionFind"
	},
	"KruskalMST": {
		"prefix": "KruskalMST",
		"body": [
			"class KruskalMST:",
			"    \"\"\"Kruskal's algorithm for finding the Minimum Spanning Tree (MST) of a graph.\"\"\"",
			"",
			"    def __init__(self, size: int):",
			"        self._size = size",
			"        self._edges_ = []",
			"",
			"    def add_edge(self, u: int, v: int, w: int):",
			"        self._edges_.append((w, u, v))",
			"",
			"    def kruskal(self) -> Tuple:",
			"        \"\"\"Run Kruskal's algorithm to find the MST of the graph.\"\"\"",
			"        self._edges_.sort()  # Sort edges by weight",
			"        uf = Std.UnionFind(self._size)",
			"        mst = []",
			"        tot_w = 0",
			"",
			"        for w, u, v in self._edges_:",
			"            if uf.find(u) != uf.find(v):",
			"                uf.union(u, v)",
			"                mst.append((u, v, w))",
			"                tot_w += w",
			"",
			"        return mst, tot_w"
		],
		"description": "KruskalMST"
	},
	"BinaryTree": {
		"prefix": "BinaryTree",
		"body": [
			"class BinaryTree:",
			"    \"\"\"Binary Indexed Tree for efficient prefix sum and range queries, with optional custom operation tracking. ",
			"    Tree 1-base index, and update and query function also! ",
			"    Array 0-base index.\"\"\"",
			"",
			"    def __init__(self, n: int, operation=lambda x, y: x + y, default=0, array=None):",
			"        self._n = n",
			"        self._operation = operation",
			"        self._default = default",
			"        self._tree_ = Arr.array(default, self._n + 1)",
			"",
			"        if array:",
			"            for i, value in enumerate(array, 1):",
			"                self.update(i, value)",
			"",
			"    def update(self, i: int, value: int):",
			"        \"\"\"Update the value at index i.\"\"\"",
			"        while i <= self._n:",
			"            self._tree_[i] = self._operation(self._tree_[i], value)",
			"            i += i & -i",
			"",
			"    def query(self, i: int) -> int:",
			"        \"\"\"Query the result of the operation up to index i.\"\"\"",
			"        res = self._default",
			"        while i > 0:",
			"            res = self._operation(res, self._tree_[i])",
			"            i -= i & -i",
			"        return res",
			"",
			"    def range_query(self, l: int, r: int) -> int:",
			"        \"\"\"Query the result of the operation in [l, r].\"\"\"",
			"        return self.query(r) - self.query(l - 1)",
			"",
			"    @staticmethod",
			"    def discretize(array):",
			"        \"\"\"Discretize the array and return the mapping dictionary. Index starts from 1\"\"\"",
			"        sorted_unique = sorted(set(array))",
			"        mapping = {val: idx + 1 for idx, val in enumerate(sorted_unique)}",
			"        return [mapping[val] for val in array], mapping",
			"",
			"class DifferenceBinaryTree:",
			"    \"\"\"Difference Array using Binary Indexed Tree for range updates and point queries.\"\"\"",
			"",
			"    def __init__(self, n: int, array=None):",
			"        if array is None:",
			"            array = []",
			"        self._n = n",
			"        self._diff_tree = Std.BinaryTree(self._n, lambda x, y: x + y)",
			"        if array:",
			"            for i in range(1, self._n + 1):",
			"                delta = array[i - 1] - (array[i - 2] if i > 1 else 0)",
			"                self._diff_tree.update(i, delta)",
			"",
			"    def update_add(self, l: int, r: int, delta: int):",
			"        \"\"\"Update the values in the range [l, r] by adding delta\"\"\"",
			"        self._diff_tree.update(l, delta)",
			"        self._diff_tree.update(r + 1, -delta)",
			"",
			"    def query_value(self, i: int) -> int:",
			"        \"\"\"Query the value at index i\"\"\"",
			"        return self._diff_tree.query(i)"
		],
		"description": "BinaryTree"
	},
	"PrimeSieve": {
		"prefix": "PrimeSieve",
		"body": [
			"class PrimeSieve:",
			"    def __init__(self, n: int):",
			"        \"\"\"",
			"        Initializes the sieve with a given n.",
			"        \"\"\"",
			"        self._n = n",
			"        self._is_prime_ = Arr.array(True, n + 1)",
			"        self.d_cnt = Arr.array(1, n + 1)  # divisior count",
			"        self.d_sum = Arr.array(1, n + 1)  # divisior sum",
			"        self._num1 = Arr.array(0, n + 1)  # Array to store the count of the smallest prime factor (min_prime_factor_count)",
			"        self._num2 = Arr.array(0, n + 1)  # Array to store the sum of the smallest prime factor's divisior sum",
			"        self.primes = []",
			"        self._generate_sieve()",
			"",
			"    def _generate_sieve(self):",
			"        \"\"\"",
			"        Generates the sieve using the linear sieve algorithm.",
			"        Computes primes, divisor counts, and divisor sums.",
			"        \"\"\"",
			"        self._is_prime_[0] = self._is_prime_[1] = False",
			"        self.d_cnt[1] = 1",
			"        self.d_sum[1] = self._num2[1] = 1",
			"",
			"        for i in range(2, self._n + 1):",
			"            if self._is_prime_[i]:",
			"                self.primes.append(i)",
			"                self._num1[i], self.d_cnt[i] = 1, 2",
			"                self._num2[i] = self.d_sum[i] = i + 1",
			"            for p in self.primes:",
			"                m = i * p",
			"                if i * p > self._n:",
			"                    break",
			"                self._is_prime_[i * p] = False",
			"                if i % p == 0:  # This ensures that each composite number is only marked by its smallest prime factor.",
			"                    self._num1[m] = self._num1[i] + 1",
			"                    self.d_cnt[m] = self.d_cnt[i] // self._num1[m] * (self._num1[m] + 1)",
			"                    self._num2[m] = self._num2[i] * p + 1",
			"                    self.d_sum[m] = self.d_sum[i] // self._num2[i] * self._num2[m]",
			"                    break",
			"                else:",
			"                    self._num1[m] = 1",
			"                    self.d_cnt[m] = self.d_cnt[i] * 2",
			"                    self._num2[m] = p + 1",
			"                    self.d_sum[m] = self.d_sum[i] * self._num2[m]"
		],
		"description": "PrimeSieve"
	},
	"Graph": {
		"prefix": "Graph",
		"body": [
			"class Graph:",
			"    def __init__(self, n: int):",
			"        self._n = n",
			"        self._graph_ = Arr.graph(n)",
			"        # self._graph_ = defaultdict(list)",
			"",
			"    def add_edge(self, u: int, v: int, w: int):",
			"        \"\"\"Add an edge to the graph.\"\"\"",
			"        self._graph_[u].append((v, w))"
		],
		"description": "Graph"
	},
	"Tree": {
		"prefix": "Tree",
		"body": [
			"class Tree:",
			"    def __init__(self, n: int):",
			"        self._n = n",
			"        self._g_ = Arr.graph(n)  # Create adjacency list",
			"        self.depth_ = Arr.array(0, n)  # Depth array for each node",
			"        self.size_ = Arr.array(1, n)  # Size of the subtree rooted at each node",
			"        self.dist_ = Arr.array(0, n)  # Distance sum of all nodes from the current node",
			"        self.dp_ = Arr.array(0, n)  # Longest path in subtree rooted at each node",
			"        self.diameter = 0  # Store the diameter of the tree",
			"",
			"    def add_edge(self, u: int, v: int, w: int):",
			"        \"\"\"Add an edge to the graph.\"\"\"",
			"        self._g_[u].append((v, w))",
			"",
			"    def dfs(self, u: int, fa: int):",
			"        \"\"\"",
			"        First DFS to calculate depth, size of subtrees, and initial distance sum (for the root).",
			"",
			"        Args:",
			"            u (int): Current node.",
			"            fa (int): Parent node of the current node.",
			"        \"\"\"",
			"        for v, w in self._g_[u]:",
			"            if fa == v:",
			"                continue",
			"            self.depth_[v] = self.depth_[u] + w  # Calculate depth",
			"            self.dfs(v, u)",
			"            self.size_[u] += self.size_[v]  # Calculate subtree size",
			"            self.dist_[u] += self.dist_[v] + self.size_[v] * w  # Update the root's initial distance sum",
			"            self.dp_[u] = Math.max(self.dp_[u], self.dp_[v] + w)  # Longest path in the subtree",
			"",
			"    def dfs_cal_dist(self, u: int, fa: int):",
			"        \"\"\"",
			"        DFS to calculate the distance sum for each node based on its parent's distance sum.",
			"",
			"        Args:",
			"            u (int): Current node.",
			"            fa (int): Parent node of the current node.",
			"        \"\"\"",
			"        for v, w in self._g_[u]:",
			"            if fa == v:",
			"                continue",
			"            # Calculate the distance sum for child node v using the parent's distance sum",
			"            self.dist_[v] = self.dist_[u] + self._n - 2 * self.size_[v]",
			"            self.dfs_cal_dist(v, u)",
			"",
			"    def dfs_cal_diameter(self, u: int, fa: int) -> int:",
			"        \"\"\"",
			"        DFS to calculate the diameter of the tree.",
			"",
			"        Args:",
			"            u (int): Current node.",
			"            fa (int): Parent node of the current node.",
			"        \"\"\"",
			"        max1, max2 = 0, 0",
			"        for v, w in self._g_[u]:",
			"            if fa == v:",
			"                continue",
			"            cand = self.dfs_cal_diameter(v, u) + w",
			"            if cand > max1:",
			"                max2 = max1",
			"                max1 = cand",
			"            elif cand > max2:",
			"                max2 = cand",
			"",
			"        self.diameter = Math.max(self.diameter, max1 + max2)  # Update the diameter",
			"        return max1"
		],
		"description": "Tree"
	},
	"init": {
		"prefix": "init",
		"body": [
			"# 3.8.9 import",
			"import bisect",
			"from collections import Counter, defaultdict, deque",
			"from datetime import datetime, timedelta",
			"from functools import lru_cache, reduce",
			"from heapq import heapify, heappop, heappush, nlargest, nsmallest",
			"from itertools import combinations, compress, permutations, starmap, tee",
			"from math import ceil, fabs, floor, gcd, log, sqrt, comb, perm",
			"from string import ascii_lowercase, ascii_uppercase",
			"from sys import exit, setrecursionlimit, stdin",
			"from typing import Any, Callable, Dict, List, Optional, Tuple, TypeVar",
			"",
			"# Constants",
			"TYPE = TypeVar('TYPE')",
			"N = int(2e5 + 10)",
			"M = int(20)",
			"INF = int(1e12)",
			"OFFSET = int(100)",
			"MOD = int(1e9 + 7)",
			"",
			"# Set recursion limit",
			"setrecursionlimit(int(2e9))",
			"",
			"class Arr:",
			"    array = staticmethod(lambda x=0, size=N: [x() if callable(x) else x for _ in range(size)])",
			"    array2d = staticmethod(lambda x=0, rows=N, cols=M: [Arr.array(x, cols) for _ in range(rows)])",
			"    graph = staticmethod(lambda size=N: [[] for _ in range(size)])",
			"",
			"class Math:",
			"    max = staticmethod(lambda a, b: a if a > b else b)",
			"    min = staticmethod(lambda a, b: a if a < b else b)",
			"",
			"class IO:",
			"    input = staticmethod(lambda: stdin.readline().strip())",
			"    read = staticmethod(lambda: map(int, IO.input().split()))",
			"    read_list = staticmethod(lambda: list(IO.read()))",
			"    read_mixed = staticmethod(lambda *types: [t(v) for t, v in zip(types, IO.input().split())])",
			"",
			"class Std:",
			"    pass",
			"",
			"#  Division line "
		],
		"description": "init python(3.8.19) code"
	},
	"Bitset": {
		"prefix": "Bitset",
		"body": [
			"class Bit(int):",
			"    def __new__(cls, value):",
			"        return super(Bit, cls).__new__(cls, value)",
			"",
			"    def __init__(self, value):",
			"        self.bin_rep = bin(value)[2:]",
			"",
			"    def bit_length(self): return len(self.bin_rep)",
			"    def bit_count(self): return self.bin_rep.count('1')",
			"    def lowest1(self): return Bit(self & -self)",
			"    def lowest0(self): return Bit(~self & (self + 1))",
			"    def clear_lowest1(self): return Bit(self & (self - 1))",
			"    def clear_lowest0(self): return Bit(self | (self + 1))",
			"    def get_bits(self, start, end): return self & Bit.range_mask(start, end)",
			"    def __or__(self, other): return Bit(super(Bit, self).__or__(other))",
			"    def __and__(self, other): return Bit(super(Bit, self).__and__(other))",
			"    def __sub__(self, other): return Bit(super(Bit, self).__and__(~other))",
			"    def __contains__(self, other): return self & other == other",
			"",
			"    all_ones_mask = staticmethod(lambda length: (1 << length) - 1)",
			"    all_zeros_mask = staticmethod(lambda length: 0)",
			"    single_bit_mask = staticmethod(lambda position: 1 << position)",
			"    range_mask = staticmethod(lambda start, end: ((1 << (end - start + 1)) - 1) << start)"
		],
		"description": "Bitset"
	}
}